#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <string>
#include <Windows.h>
#include <fstream>
using namespace std;

//Загружает теорию в файл (Потому что кодировка глючит)
void InizializTeory()
{
	string Teory = "\tШифрование — обратимое преобразование информации в целях сокрытия от неавторизованных лиц с предоставлением в это же время авторизованным пользователям доступа к ней. Главным образом шифрование служит задачей соблюдения конфиденциальности передаваемой информации. Важной особенностью любого алгоритма шифрования является использование ключа, который утверждает выбор конкретного преобразования из совокупности возможных для данного алгоритма.\n\tПользователи являются авторизованными, если они обладают определённым аутентичным ключом.Вся сложность и, собственно, задача шифрования состоит в том, как именно реализован этот процесс.\n\tВ целом, шифрование состоит из двух составляющих — зашифрование и расшифрование.\n\tС помощью шифрования обеспечиваются три состояния безопасности информации :\n\t\t• Конфиденциальность.Шифрование используется для скрытия информации от неавторизованных пользователей при передаче или при хранении.\n\t\t• Целостность.Шифрование используется для предотвращения изменения информации при передаче или хранении.\n\t\t• Идентифицируемость.Шифрование используется для аутентификации источника информации и предотвращения отказа отправителя информации от того факта, что данные были отправлены именно им.\n\tДля того, чтобы прочитать зашифрованную информацию, принимающей стороне необходимы ключ и дешифратор(устройство, реализующее алгоритм расшифровывания).\n\tКлюч — секретная информация, используемая криптографическим алгоритмом при зашифровании / расшифровании сообщений, постановке и проверке цифровой подписи, вычислении кодов аутентичности(MAC).При использовании одного и того же алгоритма результат шифрования зависит от ключа.Для современных алгоритмов сильной криптографии утрата ключа приводит к практической невозможности расшифровать информацию.\n\tИдея шифрования состоит в том, что злоумышленник, перехватив зашифрованные данные, и не имея к ним ключа, не может ни прочитать, ни изменить передаваемую информацию.Кроме того, в современных криптосистемах(с открытым ключом) для шифрования, расшифрования данных могут использоваться разные ключи.Однако, с развитием криптоанализа, появились методики, позволяющие дешифровать закрытый текст без ключа.Они основаны на математическом анализе переданных данных.\n";
	string Teory1 = "\n\t1.1.	Цели шифрования"
		"\n\tШифрование применяется для хранения важной информации в ненадёжных источниках и передачи её по незащищённым каналам связи.Такая передача данных представляет из себя два взаимно обратных процесса :"
		"\n\t\t•	Перед отправлением данных по линии связи или перед помещением на хранение они подвергаются зашифровыванию."
		"\n\t\t•	Для восстановления исходных данных из зашифрованных к ним применяется процедура расшифровывания."
		"\n\tШифрование изначально использовалось только для передачи конфиденциальной информации.Однако впоследствии шифровать информацию начали с целью её хранения в ненадёжных источниках.Шифрование информации с целью её хранения применяется и сейчас, это позволяет избежать необходимости в физически защищённом хранилище."
		"\n\tШифром называется пара алгоритмов, реализующих каждое из указанных преобразований.Эти алгоритмы применяются к данным с использованием ключа.Ключи для шифрования и для расшифровывания могут различаться, а могут быть одинаковыми.";
	string Teory2 = "\n\n\t1.2.	Зашифровывание и расшифровывание"
		"\n\tКак было сказано, шифрование состоит из двух взаимно обратных процессов : зашифрование и расшифрование.Оба этих процесса на абстрактном уровне представимы математическими функциями, к которым предъявляются определённые требования.Математически данные, используемые в шифровании, представимы в виде множеств, над которыми построены данные функции.Иными словами, пусть существуют два множества, представляющие данные — M, C; и каждая из двух функций(шифрующая и расшифровывающая) является отображением одного из этих множеств в другое."
		"\n\tЗашифровывающая функция : E:M->C"
		"\n\tРасшифровывающая функция : D:C->M"
		"\n\tЭлементы этих множеств — m и c — являются аргументами соответствующих функций.Также в эти функции уже включено понятие ключа.То есть, тот необходимый ключ для зашифровывания или расшифровывания является частью функции."
		"\n\tE(k1(m)) = c"
		"\n\tD(k2(c)) = m"
		"\n\tЕсли для зашифровывания и расшифровывания используется один и тот же ключ K = K_1 = K, то такой алгоритм относят к симметричным.Если же из ключа шифрования алгоритмически сложно получить ключ расшифровывания, то алгоритм относят к асимметричным, то есть к алгоритмам с открытым ключом."
		"\n\tВажной характеристикой шифрующей функции E является её криптостойкость.Косвенной оценкой криптостойкости является оценка взаимной информации между открытым текстом и шифротекстом, которая должна стремиться к нулю.";
	string Teory3 = "\n\n\t1.3.	Методы шифрования"
		"\n\tСимметричное шифрование использует один и тот же ключ и для зашифровывания, и для расшифровывания."
		"\n\tАсимметричное шифрование использует два разных ключа : один для зашифровывания(который также называется открытым), другой для расшифровывания(называется закрытым)."
		"\n\tЭти методы решают определённые задачи и обладают как достоинствами, так и недостатками.Конкретный выбор применяемого метода зависит от целей, с которыми информация подвергается шифрованию.";
	string Teory4 = "\n\n\t1.3.1.	Симметричное шифрование"
		"\n\tВ симметричных криптосистемах для шифрования и расшифровывания используется один и тот же ключ.Отсюда название — симметричные.Алгоритм и ключ выбирается заранее и известен обеим сторонам.Сохранение ключа в секретности является важной задачей для установления и поддержки защищённого канала связи.В связи с этим, возникает проблема начальной передачи ключа(синхронизации ключей).Кроме того, существуют методы криптоатак, позволяющие так или иначе дешифровать информацию, не имея ключа или же с помощью его перехвата на этапе согласования.В целом эти моменты являются проблемой криптостойкости конкретного алгоритма шифрования и являются аргументом при выборе конкретного алгоритма."
		"\n\tСимметричные, а конкретнее, алфавитные алгоритмы шифрования были одними из первых алгоритмов.Позднее было изобретено асимметричное шифрование, в котором ключи у собеседников разные.";
	string Teory5 = "\n\n\t1.3.2.	Асимметричное шифрование"
		"\n\tВ системах с открытым ключом используются два ключа — открытый и закрытый, связанные определённым математическим образом друг с другом.Открытый ключ передаётся по открытому(то есть незащищённому, доступному для наблюдения) каналу и используется для шифрования сообщения и для проверки ЭЦП.Для расшифровки сообщения и для генерации ЭЦП используется секретный ключ."
		"\n\tДанная схема решает проблему симметричных схем, связанную с начальной передачей ключа другой стороне.Если в симметричных схемах злоумышленник перехватит ключ, то он сможет как «слушать», так и вносить правки в передаваемую информацию.В асимметричных системах другой стороне передается открытый ключ, который позволяет шифровать, но не расшифровывать информацию.";


	ofstream outTeory("Teory/Teory.txt",ios::out);

	outTeory << Teory;
	outTeory << Teory1;
	outTeory << Teory2;
	outTeory << Teory3;
	outTeory << Teory4;
	outTeory << Teory5;

	outTeory.close();
}